> ### 프로젝트 실행 방법

```js
npm install
npm run dev
```

> #### 테스트 실행 방법

**테스트 실행 브라우저 설치**

```
npm run install:e2e
```

**기본 테스트 실행**

```
npm run test:e2e
```

**UI 모드 테스트**

```
npm run test:e2e-ui
```

---

> ### 개발 계획 및 설계 과정

- **도메인의 확장성과 복잡성을 고려한 DDD 아키텍처 적용**

현재 도메인인 상품은 주문, 결제, 재고, 프로모션 등 다양한 기능들로 확장될 수 있기 때문에 복잡도가 높은 도메인이 될 수 있고, 이는 도메인의 경계가 넓고 기능이 복잡해질 수 있음을 의미하므로 DDD 아키텍쳐를 적용하기 좋을 것으로 판단했습니다.

도메인 모델을 기준으로 분리할 경우, 설계할 때와 개발 시 초기 복잡도가 높아진다는 단점이 있었지만 장기적인 관점에서 확장성과 유지보수성을 위해 감수할만한 트레이드 오프라고 생각했습니다.

처음에는 비즈니스 로직을 어떤 폴더에 어떻게 배치할지에 대한 고민이 많았습니다.
특히 파일 구조와 폴더 네이밍 측면에서 여러 시행착오를 겪었고, 각 도메인이 독립적으로 구성될 수 있는 구조를 고민하며 개선해 나갔습니다.

이 과정에서 [Frontend Fundamentals](https://frontend-fundamentals.com/code-quality/code/examples/code-directory.html)의 자료와 해당 페이지의 코멘트를 참고하여 구조 설계의 방향성을 잡을 수 있었습니다.

- **요구사항 명확하게 이해하기**

개발하기 이전 단계에서의 요구사항 분석과 설계는 전체 프로젝트의 품질을 좌우한다고 생각합니다.

잘못된 요구사항 이해는 잘못된 결과물로 이어지는 연쇄적인 문제가 된다고 생각하여 요구사항을 명확하게 정리하고 체크리스트 형태로 세분화하여 설계 및 개발의 기준점으로 삼았습니다.
(체크리스트는 리드미 최하단에 있어요!)

> ### 폴더 구조

```
├── src/
│   ├── app/           # Next.js App Router
│   ├── common/        # Shared utilities and components
│   │   ├── components/    # Shared UI components
│   │   ├── providers/     # Context providers
│   │   ├── layouts/       # Layout components
│   │   ├── hooks/         # Shared hooks
│   │   ├── constants/     # Shared constants
│   │   └── types/         # Shared types
│   │
│   ├── domains/       # Domain-driven design
│   │   ├── product/       # Product domain
│   │   │   ├── components/    # Product-specific components
│   │   │   ├── hooks/         # Product-specific hooks
│   │   │   ├── constants/     # Product-specific constants
│   │   │   ├── infras/        # Product infrastructure (API, Query, QueryParams)
│   │   │   ├── utils/         # Product utilities
│   │   │   ├── services/      # Product services
│   │   │   ├── types/         # Product types
│   │   │   └── form/          # Product form components
│   │   │
│   │   └── brand/        # Brand domain
│   │
│   └── fonts/         # Font files
│
└── __e2e__/           # E2E tests
```

> ### 기술 스택

**Core**

- Next.js 15.3.3 (App Router)
- React 19
- TypeScript

**UI/UX**

- Tailwind CSS
- Radix UI
  - Dialog
  - Form
  - Select
  - Toast
- Sonner (Toast notifications)

**State Management & Data Fetching**

- TanStack Query (React Query)
- React Query DevTools

**Form Handling**

- React Hook Form
- Zod (Schema validation)
- @hookform/resolvers

**Testing**

- Playwright (E2E Testing)

**Development Tools**

- ESLint
- Prettier
  - prettier-plugin-tailwindcss
- Turbopack

> ### 유비쿼터스 언어

| 용어                       | 정의                                        | 세부사항                                                                                                                                                                              |
| -------------------------- | ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 상품(Product)              | 상품의 기본 정보를 담고 있는 도메인 객체    | • title: 상품명<br>• description: 상품 설명<br>• price: 가격<br>• discountPercentage: 할인율<br>• brand: 브랜드<br>• rating: 평점<br>• reviews: 리뷰 수<br>• thumbnail: 썸네일 이미지 |
| 브랜드(Brand)              | 상품의 제조사/판매사를 나타내는 도메인 객체 | • Apple<br>• Samsung<br>• Weebur                                                                                                                                                      |
| 뷰 타입(ViewType)          | 상품 목록의 표시 방식을 정의하는 열거형     | • List: 한 줄에 1개 아이템 표시<br>• Grid: 한 줄에 4개 아이템 표시                                                                                                                    |
| 쿼리 파라미터(QueryParams) | API 요청 시 사용되는 파라미터               | • select: 조회할 필드 지정<br>• limit: 페이지당 아이템 수 (기본값: 20)                                                                                                                |
| 폼(Form)                   | 상품 생성/수정을 위한 입력 폼               | • 필수 필드: title, price, brand<br>• 선택 필드: description, discountPercentage                                                                                                      |

> ### 개발중 경험했던 이슈 & 주요 고려사항

**1. 라이브러리 선택**

실무 환경을 가정하여 기획자, 디자이너 등 협업자와의 원활한 커뮤니케이션을 우선으로 고려하되 개발자 관점에서는 일관된 DX와 가독성이 높은 코드 유지가 가능하고 경량화된 라이브러리를 선택하고자 했습니다.

또, 디자이너의 시안과 일치하는 UI를 구현하기 위해서는 디자인 커스터마이징의 유연성이 중요하다고 판단하여 이 관점에서 적절한 라이브러리를 선택하는데 저 다음과 같은 부분을 고려하여 Radix UI를 사용하게 되었습니다.

1. Headless 컴포넌트 기반으로 접근성, 키보드 내비게이션, 상태 관리 등의 핵심 기능을 제공
2. 원하는 마크업과 스타일을 자유롭게 적용할 수 있어 디자이너의 의도와 일치하는 UI 구현이 용이
3. 시맨틱한 HTML 구조와 접근성 측면에서도 우수함

스타일링 도구로는 TailwindCSS를 선택했으나, 이 선택이 쉽게 결정된 것은 아니었습니다.

평소 호불호가 많이 갈리는 라이브러리라는 점에서 저 역시 기존에 좀 더 익숙했던 CSS Modules, SCSS, Styled Components에 비해 낯선 문법과 작성 방식에 대한 부담이 있었습니다.

처음에는 익숙한 도구를 사용하는 것이 생산성 측면에서 유리할 수도 있겠다는 고민을 수도 없이 했지만 그럼에도 불구하고 Tailwind CSS를 선택한 이유는 다음과 같은 기술적, 협업적 장점이 명확했기 때문입니다.

먼저 앞서 선택한 Radix UI와 높은 호환성을 가지고 있다는 점입니다.

Radix UI가 Headless 방식으로 동작하고 있었기 때문에 스타일링의 자유도가 높아야 했는데요, TailwindCSS의 유틸리티 기반 접근 방식이 RadixUI 컴포넌트 구조와 잘 맞아 떨어진다는 점에서 익숙하지 않더라도 장점이 분명했기 때문에 생소하다는 이유로 배제하긴 어려웠습니다.

두번째로 빠른 프로토타이핑에 있어서 클래스 기반의 스타일링으로 UI 개발에 있어 속도가 크게 높아진다는 점, 디자인 변경에도 빠른 대응을 할 수 있다고 기대했기 때문입니다.

세번째로는 최근 프론트엔드 생태계에서 높은 채택률을 가지고 있다는 점에서 팀 차원의 안정성, 레퍼런스 확보, CSS_in-JS에 비해 낮은 런타임 비용 등 여러 실용적인 이유로 실무에 적합하다고 판단했습니다.

**2. 일반화와 추상화**

공통 컴포넌트를 기준으로 재사용할 수 있는 컴포넌트를 추출하여 일관된 사용자 경험을 유지할 수 있도록 구현하고자 했습니다.

API 호출이나 에러 처리, 로딩 상태 등의 비동기 로직은 커스텀 훅으로 만들어 관심사를 분리하여 코드의 응집도를 높이고자 했습니다.

이 과정에서 고려했던 포인트 중 하나로 컴포넌트의 추상화 레벨을 가능한 한 유사하게 유지하는 것이었습니다.
예를 들어 `src/app/products/new/page.tsx` 와 같은 페이지에서 구성 요소의 역할과 책임이 비슷한 레벨로 추상화될 수 있도록 리팩토링을 진행했는데요, 리팩토링하는 과정에서 중요하게 생각했던 부분으로 각 컴포넌트나 훅이 어디까지 알고 있어야하는가?였습니다. 불필요한 의존성을 최소화하고 구조적 명확성을 높이는데 집중하여 설계하고자 했습니다.

상품 등록 페이지같은 경우의 요구사항을 간단하게 나열해본다면 다음과 같을 것 입니다.

1. 사용자는 상품 등록 폼에 데이터를 입력한다.
2. 폼에서 입력한 값을 기반으로 유효성 검증을 한다.
3. 검증이 통과하면 서버로 데이터를 전송한다.

이때 유효성 검증 로직은 폼 컴포넌트 내부가 아닌 별도의 훅 등으로 분리하여 관리하도록 했습니다.
폼은 단순히 UI와 사용자의 입력 처리에 집중하는 역할을 하도록 하고 검증 로직이나, 최종 가격을 연산하는 로직의 역할과 분리하여 자신의 역할만 책임지는 구조로 설계하고자 했습니다.

리팩토링하면서 매순간 들었던 생각은 어느정도 수준으로 추상화 레벨을 맞출까였습니다.
아쉽게도 모든 부분의 추상화 레벨을 유사하게 맞추는 건 현실적으로 어려운 부분이 있었고, 실제로 몇몇 부분은 현재도 개선 여지가 남아 있는 숙제라고 생각됩니다.

특히 느꼈던 점은 과도한 추상화는 오히려 코드의 가독성과 디버깅 효율을 떨어뜨릴 수 있다는 점이었습니다.
공통 로직을 무리하게 일반화한다거나, 실제로 필요한 정보보다 너무 적게 노출되는 과도한 추상화는 오히려 이해하기 어렵고 수정하기 불편한 구조로 이어진다는 점이었는데요, 저는 이러한 부분을 해결하기 위해서 다음과 같은 원칙을 중심으로 리팩토링 방향을 잡아갔습니다.

1. 추상화는 사용하는 입장에서 더 단순해 질 수 있을 때 적용한다.
2. 공통화하더라도 예외 상황이 많은 경우 또는 재사용이 많지 않을 것으로 판단되는 경우 과감히 제외한다.
3. 한 컴포넌트가 최소한의 정보만 알도록 책임 범위를 제한한다.

아직 현재 코드에서 더 개선될 여지가 있다고 판단하고 있지만, 적절한 추상화/일반화는 무엇인가에 대한 나름대로 기준을 잡아가고 개선하려고 했다는 점에서 의미 있는 경험이라고 생각합니다.

**3. 도메인을 기준으로 한 폴더 구조**

도메인을 기준으로 폴더 구조를 나누는 방식은 이번 프로젝트에서 처음으로 시도해본 설계 접근이었습니다.
단순히 기능 단위가 아닌, 비즈니스 도메인 중심의 폴더 구조로 전환하면서 초기에는 기대했던 것처럼 DDD 아키텍쳐를 잘 활용하여 기능별 응집도와 확장성 등의 이점을 확보할 수 있을 것이라 생각했습니다.

하지만 실제로는 다음과 같은 어려움이 있었습니다.

- 특정 컴포넌트나 로직이 여러 도메인에 걸쳐 사용된다면 어떤 폴더에 위치시켜야 할까?
- UI 컴포넌트와 도메인 로직의 애매한 경계에 있는 경우 폴더 위치를 잘못 배치한다면 오히려 구조가 복잡해질 수 있다.
- 도메인별 책임을 가진 UI는 도메인 내부에 위치시키고 있는데 적절한 네이밍을 어떻게 해야할까?

기준 정립과 반복적인 리팩토링을 통해 점차 구조의 일관성을 유지해서 처음에는 파일과 폴더하나를 만드는 데에도 생각하는 시간이 오래 걸렸던 것 같습니다.

위와 같은 물음과 어려움을 해소하기 위해서 도메인 하위에 일관된 방식의 네이밍(hooks, constants, compnents...)을 유지하여 해결하고자 했습니다.

아쉽게도 이번 프로젝트에서는 Products 도메인에 모든 로직이 집중되어 있어서 여러 도메인 간의 경계 설정이라던가 폴더 구조 분리는 제한적으로만 시도해볼 수 있었던 것 같습니다.

향후 도메인이 확장되더라도 지금 정립한 구조와 네이밍 컨벤션을 그대로 확장 적용해볼 수 있을 것으로 기대하고 있고, 완성된 구조라고 보기는 어렵지만 도메인 중심 설계의 가능성과 실무에서 적용해볼 수 있는 이슈들을 경험하고 정리해볼 수 있었따는 점에서 도메인 구조 설계의 초석을 다지는 계기가 되었다고 생각합니다.

**4. 느슨한 설계 (라이브러리에 종속되지 않는 구조 만들기)**

프로젝트 초반부터 의도했던 방향 중 하나는 특정 라이브러리에 종속되지 않는 유연한 구조를 유지하는 것이었습니다.

예를 들어, 폼 유효성 검증을 위해 Zod를 사용했는데 이를 직접 폼 컴포넌트에서 사용하는 것이 아니라 중간 추상 계층(어댑터)을 두어 사용하는 방식으로 설계했습니다.

이는 다음과 같은 이유에서 시도되었는데요.

1. 향후 Zod 외 다른 유효성 라이브러리(Yup, Joi 등)로 교체되는 것을 염두하여 라이브러리에 대한 강한 결합을 지양하도록 한다.
2. 유효성 로직과 UI 로직의 결합도를 낮춰서 핵심 로직만 독립적으로 테스트가 가능하도록 구성한다.

이를 위해서 `buildSelectZodSchema` 어댑터를 만들어서 zod 스키마를 각 type(text, textarea 등) 폼 필드 요구사항에 존재하는 빌더를 생성하도록 책임을 분리하여 설계했습니다.

내부적으로는 유효성 규칙 validationRule(Validation 타입)에 맞춰서 Zod 체인을 동적으로 조립시키고 외부에서는 다음과 같은 형태로 사용할 수 있도록 추상화해보았습니다.

```ts
// productFormSchema.ts
const fieldSchema = buildZodSchema({
  type: field.type,
  validationRule: rule,
  optional: field.required,
});
```

이 구조를 만들면서 컴포넌트는 `zod`를 직접 알 필요가 없게되어 낮은 결합도를 갖게 된다는 이점이 있었습니다.

유효성 로직 자체는 그대로 유지하면서 zodBuilder를 확장하거나 교체하는 방식으로 확장성을 확보할 수 있도록 가능했고 옵셔널이나 전처리 로직까지 커스텀이 가능하다는 점에서 컴포넌트가 특정 라이브러리에 의존하지 않는 설계를 만들어 볼 수 있었습니다.

가장 어려웠던 부분은 역시 타입스크립트를 사용하는 부분이었던 것 같습니다.
Zod 타입을 설정하는 부분에서는 대부분 AI 도움을 많이 받아서 해결할 수 있었지만, 직접적으로 컴포넌트에 의존하지 않고 어댑터 계층을 둠으로써 라이브러리 교체 가능성, 재사용성 등 여러 아키텍쳐적 가치를 한번 더 고민해보고 설계해보는 좋은 경험이 되었던 것 같습니다.

**5. UI/UX를 고려한 설계**

사용자 경험을 최적화하기 위해 다음과 같은 UI/UX 개선 작업을 진행했습니다.

- 스피너 처리 최적화
  초기 ViewType이 정해지지 않은 상태에서 데이터를 패칭할 때 스피너를 표시하고자 했습니다.
  이때 스피너가 너무 짧게 나타났다 사라지면 오히려 사용자 경험을 해칠 수 있다고 판단했고 이에 따라, 500ms 이상 응답 지연이 발생하는 경우에만 스피너를 노출하도록 설정하여 UX를 개선하고자 했습니다.

- 스켈레톤 컴포넌트 적용
  상품 리스트 페이지는 카드 기반의 레이아웃을 사용하고 있다는 점에서 로딩 중임을 사용자에게 직관적으로 보여줄 수 있도록 실제 카드와 유사한 형태의 스켈레톤 UI를 적용했습니다.
  이를 통해 사용자는 데이터가 불러오는 중임을 명확히 인지할 수 있고, 페이지의 시각적인 일관성 또한 확보하고자 했습니다.

- 상품 등록 시 컨펌 모달 적용
  상품 등록 시 사용자의 등록 실수 방지를 위해 확인용 모달을 추가했습니다.
  또, 최종 가격과 같은 핵심 정보에는 강조된 스타일을 적용하여 사용자가 중요한 정보로 가장 먼저 인식할 수 있도록 적용하였습니다.

- 등록 결과에 대한 명확한 피드백
  상품 등록이 성공하거나 실패했을 때, 사용자에게 등록 결과에 대한 즉각적인 피드백을 제공하기 위해 토스트 UI를 적용하였습니다.

> #### 기능 요구사항 체크리스트

- [x] 상품을 생성(등록)할 수 있다.
- [x] 상품 생성은 Form을 사용한다.
- [x] 유효성 검사를 통과해야 상품 생성을 할 수 있다.
      Validate 체크 리스트
  - [x] 필드명 title은 타입이 text이고 필수 입력이다.
  - [x] 필드명 title은 15자 이내로 입력되어야 한다.
  - [x] 필드명 description은 타입이 textarea이고 옵셔널이다.
  - [x] 필드명 description은 유효성 검사를 하지 않는다. (\*요구사항은 없지만 제한을 두는 게 좋을 것 같아 5,000자 맥시멈으로 정의했습니다.)
  - [x] 필드명 price는 타입이 number이고 필수 입력이다.
  - [x] 필드명 price는 1,000원 이상으로 입력되어야 한다.
  - [x] 필드명 discountPercentage는 타입이 number이고 옵셔널이다.
  - [x] 필드명 discountPercentage는 100 이내로 입력되어야 한다.
  - [x] 필드명 brand는 타입이 select이고, 단 1개만 필수 선택되어야 한다.
  - [x] 필드명 brand 옵션박스의 셀렉트 목록은 Apple, Samsung, Weebur이다.
- [x] 상품 생성 API는 (https://dummyjson.com/products/add) 를 호출한다.
- [x] 상품 생성이 완료되었다면 상품 리스트 페이지(/products)로 이동되어야 한다.
- [x] 최종 가격이 실시간 디스플레이 되어야한다. (입력된 price, discountPercentage를 사용한다.)

**상품 리스트 페이지**

- [x] 상품 리스트 조회 API는 (https://dummyjson.com/products)를 호출한다.
- [x] 페이지 진입 시 20개의 아이템만 노출되어야 한다.
- [x] 각 아이템은 다음의 정보를 포함해야한다.
  - [x] 상품명 (title)
  - [x] 상품설명 (description)
  - [x] 썸네일 이미지 (thumbnail)
  - [x] 별점 (rating)
  - [x] 리뷰 수 (reviews)
- [x] View 방식은 다음 두 종류로 구성된다.
  - 리스트형 (List): 한 줄에 1개 아이템
  - 그리드형 (Grid): 한 줄에 4개 아이템
- [x] View 표시 방식은 다음과 같다.
  - [x] 페이지 최초 진입 시 50% 확률로 랜덤하게 View 방식이 결정된다.
  - [x] 이용자는 페이지 진입 한 후에 배정된 View 방식 이외의 방식을 볼 수 없다.
  - [x] 결정된 View 방식은 24시간 동안 유지되어야 한다.
  - [x] 24시간 이후 재접속 시 다시 랜덤으로 View 방식이 결정된다.
  - [x] 리스트 상단에는 상품 생성 페이지(/products/new)로 이동하는 버튼이 존재해야 한다.
